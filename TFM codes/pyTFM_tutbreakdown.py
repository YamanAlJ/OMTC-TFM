##### Plotting The Deformation Field ######

from pyTFM.TFM_functions import calculate_deformation
from pyTFM.plotting import show_quiver

# paths to the images
im_path1 = "C:/Users/yaman/Desktop/example_data_for_pyTFM-master/python_tutorial/04after.tif" # change to your location
im_path2 = "C:/Users/yaman/Desktop/example_data_for_pyTFM-master/python_tutorial/04before.tif"
# calculating the deformation
u, v, mask_val, mask_std = calculate_deformation(im_path1, im_path2, window_size = 100, overlap = 60)
# the unit of window size and overlap is pixels of the image of the beads
# overlap of 95 is more accurate but calculation takes ~5 min 

# plotting the deformation field
fig1, ax = show_quiver(u, v, cbar_str="deformations\n[pixels]")

######################################################################################################################


##### A Function to Find and Extract The Common Field of View of Both Images with Subpixel Accuracy #####

from pyTFM.frame_shift_correction import correct_stage_drift
from PIL import Image
import numpy as np

# load your images; dtype must be float32; images must be grayscale (you need a 2 dimensional array)
image1 = np.asarray(Image.open("C:/Users/yaman/Desktop/example_data_for_pyTFM-master/python_tutorial/04after.tif"))
image2 = np.asarray(Image.open("C:/Users/yaman/Desktop/example_data_for_pyTFM-master/python_tutorial/04before.tif"))

# cutting out the common field of few of image1 with image2.
# This also normalizes the images and applies a subpixel
# accurate shift. You can provide an additional list of
# images that will be cut to the same field of view.
image1_cor, image2_cor, other_images, drift = correct_stage_drift(image1, image2, additional_images=[])

# saving the output
image1_cor.save("C:/Users/yaman/Desktop/example_data_for_pyTFM-master/python_tutorial/04after.tif")
image2_cor.save("C:/Users/yaman/Desktop/example_data_for_pyTFM-master/python_tutorial/04before.tif")

######################################################################################################################


##### Plotting The Traction Field #####

from pyTFM.TFM_functions import TFM_tractions
import numpy as np

# setting the elastic parameters of the substrate (Young’s modulus, Poisson’s ratio and the height of the substrate)
# also need the pixel size of the image of the beads and the pixel size of the deformation field. 
ps1 = 0.201 # pixel size of the image of the beads
im1_shape = (1991, 2033) # dimensions of the image of the beads
ps2 = ps1 * np.mean(np.array(im1_shape) / np.array(u.shape)) # pixel size of of the deformation field
young = 49000 # Young's modulus of the substrate in Pa
sigma = 0.49 # Poisson's ratio of the substrate
h = 300 # height of the substrate in µm, "infinite" is also accepted

# calculating the traction field
tx, ty = TFM_tractions(u, v, pixelsize1=ps1, pixelsize2=ps2, h=h, young=young, sigma=sigma)

# plotting the traction field
fig2, ax = show_quiver(tx, ty, cbar_str="tractions\n[Pa]")

######################################################################################################################



##### Quantifying The Force Generation  ##### 

# We don't need the mask, we work with a monolayer so we use the entire area
import matplotlib.pyplot as plt
from scipy.ndimage.morphology import binary_fill_holes
from pyTFM.grid_setup_solids_py import interpolation # a simple function to resize the mask


# loading a mask that defines the area used for measuring the force generation
mask = plt.imread("C:/Users/yaman/Desktop/example_data_for_pyTFM-master/python_tutorial/force_measurement.png").astype(bool)
mask = binary_fill_holes(mask) # the mask should be a single patch without holes
# changing the masks dimensions to fit to the deformation and traction fields
mask = interpolation(mask, dims=u.shape)

# calculating the contractillity and the strain energy
from pyTFM.TFM_functions import strain_energy_points, contractillity

# strain energy:
# first we calculate a map of strain energy
energy_points = strain_energy_points(u, v, tx, ty, ps1, ps2) # J/pixel
# then we sum all energy points in the area defined by mask
strain_energy = np.sum(energy_points[mask]) # 2.14*10**-13 J

# contractillity
contractile_force, proj_x, proj_y, center = contractillity(tx, ty, ps2, mask) # 2.03*10**-6 N

######################################################################################################################



##### Measuring Stresses in Cell Colonies ##### we don't measure stresses using pyTFM

# first mask: The area used for Finite Elements Methods
# it should encircle all forces generated by the cell colony
mask_FEM = plt.imread("C:/Users/yaman/Desktop/example_data_for_pyTFM-master/python_tutorial/force_measurement.png").astype(bool)
mask_FEM = binary_fill_holes(mask_FEM) # the mask should be a single patch without holes
# changing the masks dimensions to fit to the deformation and traction field:
mask_FEM = interpolation(mask_FEM, dims=tx.shape)

# second mask: The area of the cells. Average stresses and other values are calculated only
# on the actual area of the cell, represented by this mask.
mask_cells = plt.imread("C:/Users/yaman/Desktop/example_data_for_pyTFM-master/python_tutorial/cell_borders.png").astype(bool)
mask_cells = binary_fill_holes(mask_cells)
mask_cells = interpolation(mask_cells, dims=tx.shape)

# fixing imbalance due to fininte element methods
from pyTFM.grid_setup_solids_py import prepare_forces

# converting tractions (forces per surface area) to actual forces
# and correcting imbalanced forces and torques
# tx->traction forces in x direction, ty->traction forces in y direction
# ps2->pixel size of the traction field, mask_FEM-> mask for FEM
fx, fy = prepare_forces(tx, ty, ps2, mask_FEM)

# solving the FEM system
from pyTFM.grid_setup_solids_py import grid_setup, FEM_simulation

# constructing the FEM grid
nodes, elements, loads, mats = grid_setup(mask_FEM, -fx, -fy, sigma=0.5)
# performing the FEM analysis
# verbose prints the progress of numerically solving the FEM system of equations.
UG_sol, stress_tensor = FEM_simulation(nodes, elements, loads, mats, mask_FEM, verbose=True)
# UG_sol is a list of deformations for each node. We don't need it here.

# mean normal stress
ms_map = ((stress_tensor[:, :, 0, 0] + stress_tensor[:, :, 1, 1]) / 2) / (ps2 * 10**-6)
# average on the area of the cell colony.
ms = np.mean(ms_map[mask_cells]) # 0.0043 N/m

# coefficient of variation
cv = np.nanstd(ms_map[mask_cells]) / np.abs(np.nanmean(ms_map[mask_cells])) # 0.41 no unit

######################################################################################################################



##### Calculating The Line Tension ##### might be useful for OMTC but not for TFM
 
# forces that are transmitted across cell-cell boundaries --> quantified by the line tension

# loading a mask of the cell borders
mask_borders = plt.imread("C:/Users/yaman/Desktop/example_data_for_pyTFM-master/python_tutorial/cell_borders.png").astype(bool)

from pyTFM.grid_setup_solids_py import find_borders

# identifying borders, counting cells, performing spline interpolation to smooth the borders
borders = find_borders(mask_borders, tx.shape)
# we can for example get the number of cells from the "borders" object
n_cells = borders.n_cells # 8


from pyTFM.stress_functions import lineTension

# calculating the line tension along the cell borders
lt, min_v, max_v = lineTension(borders.lines_splines, borders.line_lengths, stress_tensor, pixel_length=ps2)
# lt is a nested dictionary. The first key is the id of a cell border.
# For each cell border the line tension vectors ("t_vecs"), the normal
# and shear component of the line tension ("t_shear") and the normal
# vectors of the cell border ("n_vecs") are calculated at a large number of points.

# average norm of the line tension. Only borders not at colony edge are used
lt_vecs = np.concatenate([lt[l_id]["t_vecs"] for l_id in lt.keys() if l_id not in borders.edge_lines])
avg_line_tension = np.mean(np.linalg.norm(lt_vecs, axis=1)) # 0.00569 N/m

# average normal component of the line tension
lt_normal = np.concatenate([lt[l_id]["t_normal"] for l_id in lt.keys() if l_id not in borders.edge_lines])
avg_normal_line_tension = np.mean(np.abs(lt_normal)) # 0.00566 N/m,
# here you can see that almost the line tensions act almost exclusively perpendicular to the cell borders.


# plotting
from pyTFM.plotting import plot_continuous_boundary_stresses

# plotting the line tension
fig3, ax = plot_continuous_boundary_stresses([borders.inter_shape, borders.edge_lines, lt, min_v, max_v], cbar_style="outside")

######################################################################################################################